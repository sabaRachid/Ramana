Produit: Ce que tu vends (riz, lait, pain)

Variante: La version exacte vendue (1kg, 5kg)

Stock location: Lâ€™endroit oÃ¹ les produits sont physiquement stockÃ©s

Inventory level: Combien de cette variante il y a dans cet endroit

Sales channel: Par quel moyen on vend (app mobile Ramana)

Lien canal â†” stock: Quel stock est utilisÃ© quand on vend via lâ€™app

1ï¸âƒ£ Route Produits

ğŸ‘‰ Question : â€œQuâ€™est-ce que je peux acheter ?â€

Cette route : demande Ã  Medusa la liste des produits; reformate la rÃ©ponse

renvoie juste : nom; prix; stock disponible

2ï¸âƒ£ Route Panier (Cart)

ğŸ‘‰ Question : â€œQuâ€™est-ce que jâ€™ai choisi ?â€

Cette route : crÃ©e un panier; ajoute des articles; modifie des quantitÃ©s

ğŸ‘‰ Le panier rÃ©serve le stock, mais ne le sort pas encore.

3ï¸âƒ£ Route Commande (Order)

ğŸ‘‰ Question : â€œJe confirme mon achatâ€

Cette route : transforme le panier en commande; dÃ©clenche le vrai workflow; le stock est rÃ©ellement consommÃ©

Une route est une porte simple qui permet Ã  ton app de demander quelque chose au backend, sans connaÃ®tre comment Ã§a fonctionne Ã  lâ€™intÃ©rieur.

SchÃ©ma simplifiÃ© du flux :
App mobile
   â†“
Routes Ramana (simples)
   â†“
Medusa (le moteur)
   â†“
Base de donnÃ©es


----------------------------------------

Contexte gÃ©nÃ©ral du projet

Le projet Ramana est un backend e-commerce minimal construit sur Medusa v2.
Lâ€™objectif nâ€™est pas de faire un e-commerce â€œclassiqueâ€ avec paiement en ligne, mais de fournir une API simple et robuste permettant Ã  une application mobile ou web de :

afficher un catalogue de produits

crÃ©er des commandes locales

gÃ©rer des commandes payÃ©es hors ligne (cash aujourdâ€™hui, mobile money plus tard)

stocker les commandes dans une base PostgreSQL

Le projet est pensÃ© pour un contexte local (Afrique de lâ€™Ouest), oÃ¹ le paiement en ligne par carte nâ€™est pas prioritaire.

Le backend doit Ãªtre suffisamment stable et figÃ© pour permettre le dÃ©veloppement de lâ€™interface sans dÃ©pendre des mÃ©canismes complexes de checkout Medusa.

Stack technique rÃ©ellement utilisÃ©e

Node.js

Medusa v2 (framework)

PostgreSQL 16

Docker (pour la base de donnÃ©es)

API Store Medusa avec routes custom

Workflows Medusa (pour la logique mÃ©tier)

Aucun usage du checkout standard Medusa

Aucun TypeORM.
Medusa v2 utilise MikroORM en interne, mais ici la persistance est gÃ©rÃ©e via un workflow et une table SQL dÃ©diÃ©e.

Objectif fonctionnel actuel (ce qui doit absolument marcher)

Exposer des produits

CrÃ©er une commande Ramana

Sauvegarder la commande en base

Retourner un objet commande propre au frontend

Tout ce qui nâ€™est pas nÃ©cessaire Ã  ces points est volontairement exclu.

Ce qui a Ã©tÃ© fait et fonctionne

Catalogue produits

Une route store custom existe :

/store/ramana/products

Elle retourne :

id produit

titre

catÃ©gorie

variantes

prix en XOF

quantitÃ© disponible

in_stock (boolÃ©en)

Cette route fonctionne.
Elle est dÃ©jÃ  utilisÃ©e avec succÃ¨s via curl.
Le contrat de rÃ©ponse est stable.

Les produits sont seedÃ©s via un script seed.ts.
Le seed crÃ©e :

catÃ©gories

produits

variantes

prix

stock initial

Le seed fonctionne correctement et peut Ãªtre rejouÃ© sans casser lâ€™Ã©tat.

CrÃ©ation de commande Ramana

Une route store custom existe :

/store/ramana/orders

Cette route permet de crÃ©er une commande sans passer par :

panier Medusa

payment collection

payment session

order Medusa natif

Payload acceptÃ© (figÃ©) :

status : "pending"

customer : { name, phone, address }

items : { lines: [...] }

payment_method : "cash"

Exemple rÃ©el validÃ© :

customer.name = string
customer.phone = string
customer.address = string

items.lines = tableau
chaque ligne contient :

variant_id

quantity

payment_method = "cash" uniquement pour lâ€™instant

La route :

calcule le subtotal

calcule le total

fixe la devise Ã  XOF

gÃ©nÃ¨re un id de commande

retourne lâ€™objet commande

La route fonctionne.
Les appels curl retournent bien une commande.

Persistance en base de donnÃ©es

Une table PostgreSQL existe et fonctionne :

ramana_order

Colonnes :

id (text, primary key)

status (text)

customer (jsonb)

items (jsonb)

payment_method (text)

subtotal (integer)

total (integer)

created_at (timestamptz)

updated_at (timestamptz)

deleted_at (timestamptz)

Les commandes sont bien insÃ©rÃ©es.
VÃ©rification directe faite via psql dans Docker.
Plusieurs lignes rÃ©elles existent dÃ©jÃ  dans la table.

Cela confirme que :

la route fonctionne

la persistance fonctionne

le schÃ©ma est valide

Workflow Ramana

La logique mÃ©tier principale est implÃ©mentÃ©e dans un workflow Medusa :

createRamanaOrderWorkflow

Ce workflow :

prend un input de commande

valide les donnÃ©es

calcule les montants

Ã©crit en base

retourne la commande crÃ©Ã©e

Un script de test existe :
test-ramana-order-workflow.ts

Ce script est une version figÃ©e et fait foi.
Il reprÃ©sente la source de vÃ©ritÃ© mÃ©tier.

Le workflow est fonctionnel.
Les commandes crÃ©Ã©es par workflow sont prÃ©sentes en base.

Ce qui est volontairement exclu du pÃ©rimÃ¨tre

Tout ce qui suit nâ€™est PAS requis pour la version actuelle :

panier Medusa standard

checkout Medusa

payment collections

payment sessions

Stripe

providers de paiement

users / customers Medusa

shipping

taxes

promotions

admin dashboard pour Ramana

Toute tentative dâ€™intÃ©grer ces Ã©lÃ©ments a causÃ© :

des erreurs de configuration

des providers introuvables

des crashes serveur

une perte de temps inutile

La dÃ©cision a Ã©tÃ© prise de ne PAS les utiliser.

Ce qui a bloquÃ© / posÃ© problÃ¨me

Tentatives dâ€™utiliser payment-manual
Le package nâ€™existe pas ou nâ€™est pas installable.
Cela a causÃ© des erreurs au dÃ©marrage.

Tentatives dâ€™utiliser Stripe sans config complÃ¨te
Stripe nÃ©cessite des clÃ©s rÃ©elles, des webhooks, etc.
Inutile pour le projet actuel.

Tentatives dâ€™accÃ©der Ã  db / manager / EntityManager
Ces objets ne sont pas exposÃ©s comme dans Medusa v1.
Awilix ne les rÃ©sout pas.
Cela provoque des erreurs du type :

Could not resolve 'db'

Could not resolve 'manager'

Tentatives de crÃ©er un module Medusa â€œpropreâ€
defineModule, MedusaService, etc. ont causÃ© :

erreurs de boot

modules non reconnus

â€œNo service found in moduleâ€

Ces pistes ont Ã©tÃ© abandonnÃ©es.

DÃ©cision finale (contrat figÃ©)

Le projet est dÃ©sormais figÃ© comme suit :

API store custom uniquement

workflow comme source de vÃ©ritÃ©

table SQL dÃ©diÃ©e ramana_order

aucune dÃ©pendance au checkout Medusa

aucune dÃ©pendance aux providers de paiement

Cette architecture fonctionne.
Elle est testÃ©e.
Elle est comprise.

Ce qui est prÃªt pour le frontend

Le frontend peut maintenant Ãªtre dÃ©veloppÃ© en toute sÃ©curitÃ© avec :

GET /store/ramana/products

POST /store/ramana/orders

Le frontend nâ€™a PAS Ã  :

gÃ©rer un panier Medusa

gÃ©rer un paiement

gÃ©rer des tokens complexes

Il envoie une commande simple.
Il reÃ§oit une commande simple.

Ce qui pourra venir plus tard (mais pas maintenant)

dÃ©crÃ©ment du stock

statuts supplÃ©mentaires

mobile money

dashboard admin Ramana

historisation avancÃ©e

Rien de cela ne bloque le frontend aujourdâ€™hui.

Conclusion

Le backend Ramana est fonctionnel.
Le contrat API est stable.
La base est valide.
Les workflows marchent.